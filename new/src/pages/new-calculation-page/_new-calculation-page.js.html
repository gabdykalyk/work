<script type="text/javascript">
  // Справочники
  window.directories = {
    fines: {
      get: () => {
        const directory = ko.observable([
          {
            name: 'Безопасность',
            items: [
              { id: 1, name: 'Возврат в кассу', sum: 200 }
            ],
          },
          {
            name: 'Дисциплина',
            items: [
              { id: 2, name: 'За отсутствие объяснительной', sum: 250 },
              { id: 3, name: 'Халатное отношение к работе', sum: 300 },
            ]
          },
          {
            name: 'Документы',
            items: [
              { id: 4, name: 'Налог', sum: 350 }
            ],
          },
          {
            name: 'Производство',
            items: [
              { id: 5, name: 'Выкуп готовой продукции', sum: 400 },
              { id: 6, name: 'Порча инвентаря и оборудования', sum: 450 },
              { id: 7, name: 'Компенсация за халатность', sum: 500 },
            ],
          },
        ]);

        return directory;
      }
    },
    authors: {
      get: () => {
        const directory = ko.observable([
          {
            id: 1,
            name: 'Иван Иванов'
          },{
            id: 2,
            name: 'Петр Петров'
          },{
            id: 3,
            name: 'Николай Николаев'
          },{
            id: 4,
            name: 'Сергей Сергеев'
          }
        ]);

        return directory;
      }
    }
  };

  $(function () {
    const $page = $(document.documentElement);



    const PositionsModel = function () {
      const positions = ko.observableArray([]);
      function getPositionById(id) {
        return positions().find(p => p().id === id);
      }

      /* Creates new list from data */
      function setPositions(positionsList) {
        positions(positionsList.map(position => {
          return PositionModel(position)
        }))
      }

      /* Updates employees set and visibility */
      function updateEmployeesList(updatedPositionsList) {
        const originalPositionsList = positions();

        updatedPositionsList.forEach(updatedPosition => {
          const employees = updatedPosition.employees;
          const updatedIds = employees.map(e => e.id);

          const originalPosition = originalPositionsList.find(p => p().id === updatedPosition.id);

          const originalPositionEmployees = originalPosition().employees();
          const originalIds = originalPositionEmployees.map(e => e.id);

          const notFoundIds = _.difference(originalIds, updatedIds);
          const newEmployeesIds = _.difference(updatedIds, originalIds);

          // удалить тех, которых нет
          const updated = originalPositionEmployees.filter(e => notFoundIds.indexOf(e.id) === -1);

          // отметить видимость
          updated.forEach(e => {
            const updatedEmployee = employees.find(employee => employee.id === e.id);
            e.visible(updatedEmployee.checked);
          });

          // добавить новых
          newEmployees = newEmployeesIds.map(id => {
            const data = employees.find(e => e.id === id);
            const employee = EmployeeModel(data, data.checked);
            return employee;
          });

          originalPosition().employees(updated.concat(newEmployees));
        });
      }

      function WorkingIntervalModel(interval) {
        const value = ko.observable(interval).extend({
          required: {
            message: 'Обязательное поле'
          },
          validation: {
            validator: value => {

              if (!/^\d\d:\d\d – \d\d:\d\d$/.test(value)) {
                return false;
              } else {
                const boundaries = value.split(' – ');

                if (boundaries[0] === boundaries[1]) {
                  return false;
                }

                return boundaries.every(b => moment(b, 'HH:mm', true).isValid());
              }
            },
            message: 'Неверный формат интервала'
          }
        });

        const getInterval = () => {
          const boundaries = value().split(' – ').map(b => moment(b, 'HH:mm'));

          if (boundaries[0].isAfter(boundaries[1])) {
            boundaries[1].add(1, 'd');
          }

          return boundaries[1].diff(boundaries[0], 'minutes');
        };

        return {
          value,
          getInterval
        };
      }

      function EmployeeModel(employee, positionData, visible) {
        const defaultIntervals = employee.workingIntervals || [''];
        const workingIntervals = ko.observableArray(
          defaultIntervals.map(i => WorkingIntervalModel(i))
        );

        const isWorkingIntervalsValid = ko.pureComputed(() => {
          return workingIntervals().every(i => i.value.isValid())
        });

        const addWorkingInterval = () => {
          const model = WorkingIntervalModel('');
          workingIntervals.push(model);
        }

        const removeWorkingInterval = (interval) => {
          workingIntervals.remove(interval);
        }

        const workingTime = ko.pureComputed(() => {
          if (!isWorkingIntervalsValid()) return 0;

          return workingIntervals().reduce((minutes, interval) => {
            return minutes + interval.getInterval();
          }, 0);
        });

        const accountOperations = ko.observableArray(employee.accountOperations || []);
        const accountState = ko.pureComputed(() => {
          return accountOperations().reduce((sum, operation) => {
            const operationSum = operation.type === 'fine' ? operation.sum * -1 : operation.sum;
            return sum + operationSum;
          }, 0)
        });

        const fines = ko.observableArray(employee.fines || []);
        const finesState = ko.pureComputed(() => {
          return fines().reduce((sum, fine) => {
            return sum + fine.sum;
          }, 0)
        });

        return {
          name: employee.name, // имя
          id: employee.id, // идентификатор
          level: employee.level, // разряд

          accountOperations,
          accountState,

          workingIntervals: workingIntervals, // рабочие интервалы
          addWorkingInterval,
          removeWorkingInterval,
          workingTime,

          returnRate: 30, // норматив выручки
          salaryBulk: 7200, // основная часть зп
          bonus: ko.observable(0), // премия

          fines, // штрафы
          finesState,

          visible: ko.observable(!!visible), // участвует в расчете
        }
      }

      function PositionModel(positionData) {
        const visible = ko.observable(false);
        const employees = ko.observableArray(positionData.employees.map((e) => EmployeeModel(e, positionData, false)));

        const workingTime = ko.pureComputed(() => {
          return employees().reduce((minutes, employee) => {
            if (!employee.visible()) return minutes;
            return minutes + employee.workingTime();
          }, 0)
        });

        const addEmployee = (employee) => {
          employees.push(EmployeeModel(employee, positionData, 'visible'));
        }

        return ko.observable({
          id: positionData.id,
          name: positionData.name, // название
          workloadType: positionData.workloadType,
          type: positionData.type, // production/delivery
          levels: positionData.levels, //
          rate: positionData.rate, // оклад
          units: 3,
          workload: 2.2, // нагрузка
          additionalWorkload: positionData.additionalWorkload,
          fotCategory: positionData.fotCategory,
          fotRevenue: positionData.fotRevenue,
          employees,
          addEmployee,

          workingTime,

          visible, // отображается в таблице
        });
      };

      return {
        positions,
        setPositions,
        updateEmployeesList,
        getPositionById,
      }
    }

    const ViewModel = function (defaultPositions, settings) {
      /** Initialization */
      (() => {
        this.subscriptions = [];
        const viewportSize = ko.observable({ width: $(window).width(), height: $(window).height() });
        this.windowResizeHandler = () => {
          viewportSize({ width: $(window).width(), height: $(window).height() });
        };
        this.childrenComplete = function () {
          $page.removeClass('hrm-page--initializing');
        };
        this.modalOpens = ko.observableArray([]);

        this.utils = {
          openModal: (id, data, onSave) => {
            const modal = createModalDialog(id, data, onSave);
            this.modalOpens.push(modal)
          },

          formatSign: (number) => {
            const formattedNumber = parseFloat(ko.unwrap(number));
            if (!formattedNumber) return number;
            if (formattedNumber > 0) return '+' + formattedNumber;
            return formattedNumber;
          },

          viewportSize: viewportSize
        }
      })();

      this.summaryModel = new PositionsModel();
      this.summaryModel.setPositions(defaultPositions);

      /** Input data */
      this.inputModel = {
        filial: ko.observable(''),
        date: ko.observable(moment().format('DD.MM.YYYY, dddd')),
        shift: ko.observable(''),
        interval: {
          start: ko.observable(''),
          end: ko.observable(''),
        }
      };

      /** Calculation */
      this.isBuilt = ko.observable(false);
      /** Get data for calculation */
      this.buildCalculation = () => {
        /** Данные */
        const inputData = ko.toJS(this.inputModel);

        /* Получение списка позиций */
        const positions = [
          TestPosition('Администратор филиала', 1, { levelCount: 0 }),
          TestPosition('Повар-сушист', 2),
          TestPosition('Повар-пиццмейкер', 3),
          TestPosition('Официант', 4),
          TestPosition('Водитель', 5, { type: 'delivery' }),
        ];

        /** Обновление представления */
        this.summaryModel.setPositions(positions);
        this.isBuilt(true);
      };

      /** Tabs: production, delivery, lateness */
      this.tabs = (() => {
        const tabs = [
          new HrmTabGroupItem('Производство'),
          new HrmTabGroupItem('Доставка'),
          new HrmTabGroupItem('Опоздания')
        ];
        const activeTab = ko.observable(0);
        return {
          tabs,
          activeTab,
        }
      })();

      this.productionPositions = ko.pureComputed(() => {
        return this.summaryModel.positions()
          .filter(position => position().type === 'production');
      })


      /** Stimulation model (fine/bonus) */
      this.stimulation = (() => {
        function Stimulation() {
          return {
            base: ko.observable(''),
            author: ko.observable(''),
            sum: ko.observable(0),
            comment: ko.observable('')
          }
        }

        const fine = {
          production: Stimulation(),
          delivery: Stimulation()
        };
        const bonus = {
          production: Stimulation(),
          delivery: Stimulation()
        };

        const setStimulation = () => {
          this.settings.openModal(
            'stimulation',
            null,
            (data) => {
              console.log('stimulation saved', data)
            }
          )
        }

        return {
          fine,
          bonus,
          set: setStimulation
        }
      })();

      this.isEmployeesCalculated = ko.observable(false);

      this.calculateEmployees = function () {
        this.isEmployeesCalculated(true);
      };

      this.recalculateEmployees = function () {
        this.isEmployeesCalculated(false);

        this.formModel().positions().forEach((position, index) => {
          position.employees(positions[index].employees.map(e => this.createEmployeeModel(e)));
        });

        this.isEmployeesCalculated(true);
      };

      this.addWorkingInterval = function (employee) {
        employee.workingIntervals.push(this.createEmployeeWorkingIntervalModel(''));
      };



      this.onRateInput = function (position) {
        position.employees().forEach(employee => {
          employee.rate(position.rate());
        });
      };

      this.onEmployeeRateInput = function (position) {
        position.rate('');
      };


      this.getWorkloadTypeName = function (workloadType) {
        switch (workloadType) {
          case 1: return 'Объём товара по всему предприятию';
          case 2: return 'Объём товара по категориям';
        }
      };

      this.getEmployeeWorkingHours = function (employee) {
        return ko.pureComputed(() => {
          if (employee.workingIntervalsValidationObject.isValid()) {
            return employee.workingIntervals().reduce((minutes, interval) => {
              const boundaries = interval.value().split(' – ').map(b => moment(b, 'HH:mm'));

              if (boundaries[0].isAfter(boundaries[1])) {
                boundaries[1].add(1, 'd');
              }

              return minutes + boundaries[1].diff(boundaries[0], 'minutes');
            }, 0);
          } else {
            return 0;
          }
        });
      };

      this.getEmployeeSalaryBulk = function (employee) {
        return ko.pureComputed(() => {
          const minutes = this.getEmployeeWorkingHours(employee)();

          return this.unmaskDecimal(employee.rate()) * (minutes / 60);
        });
      };

      this.getEmployeeSalary = function (employee) {
        return ko.pureComputed(() => {
          const bulk = this.getEmployeeSalaryBulk(employee)();
          const bonus = this.unmaskDecimal(employee.bonus());
          const fine = this.unmaskDecimal(employee.fine());

          return this.unmaskDecimal(bulk + bonus - fine);
        });
      };

      this.getPositionMaxWorkingIntervalCount = function (position) {
        return ko.pureComputed(() => {
          return Math.max(...position.employees().map(e => e.workingIntervals().length));
        });
      };

      this.getCategoriesTooltipText = function (categories) {
        return categories.map(c => c.name).join(', ');
      };

      this.getUnitsSuffixHtml = function (units) {
        switch (units) {
          case '1': return 'шт.';
          case '2': return '<i class="far fa-ruble-sign"></i>';
          case '3': return 'ч.';
        }
      };

      this.formatDecimal = function (value) {
        return Inputmask.format(value, { alias: 'decimal', digits: '2', groupSeparator: ' ', autoGroup: true, allowMinus: false }).replace('.00', '');
      };

      this.unmaskDecimal = function (value) {
        const result = Inputmask.unmask(value, { alias: 'decimal', digits: '2', groupSeparator: ' ', autoGroup: true, allowMinus: false, unmaskAsNumber: true });

        if (result === '') {
          return 0;
        }

        return result;
      };

      this.editableCellControlErrorExtractor = function (control) {
        return ko.pureComputed(() => {
          return !control.isValid() ? { message: control.error() } : null;
        });
      };

      this.formatDuration = function (minutes) {
        let h = Math.floor(minutes / 60).toString();
        h = h.length === 1 ? '0' + h : h;
        let m = (minutes % 60).toString();
        m = m.length === 1 ? '0' + m : m;

        return h + ':' + m;
      };

      this.isSidebarCollapsed = ko.observable(localStorage.getItem(HRM_SIDEBAR_COLLAPSED_LOCAL_STORAGE_KEY) === 'true');

      (() => {
        $(window).on('resize', this.windowResizeHandler);

        this.subscriptions.push(this.isSidebarCollapsed.subscribe(collapsed => {
          localStorage.setItem(HRM_SIDEBAR_COLLAPSED_LOCAL_STORAGE_KEY, collapsed);
        }));
      })();
    };


    ViewModel.prototype.dispose = function () {
      $(window).off('resize', this.windowResizeHandler);
      this.subscriptions.forEach(s => s.dispose());
    };

    /***** Model activation *******/
    const defaultPositions = [];
    const viewModel = new ViewModel(defaultPositions);

    ko.applyBindings(
      viewModel,
      $page.get()[0]
    );


    /*****/
    function TestEmployee(name, id, index, levelsCount) {
      return {
        name: name + ' #' + index,
        id: id + '–' + index,
        level: Math.floor(Math.random() * levelsCount + 1),
        workingIntervals: ['09:00 – 16:00'],

      }
    }
    function TestPosition(name, id, config) {
      config = config || {};

      let levelCount = 'levelCount' in config ? config.levelCount : Math.floor(Math.random() * 4);
      if (levelCount === 1) levelCount = 2;
      const levels = [...Array(levelCount)].map((_, i) => i + 1);

      const employeeCount = 'employeeCount' in config ? config.employeeCount : Math.floor(Math.random() * 4 + 1);
      const employees = [...Array(employeeCount)].map((_, i) => {
        return TestEmployee(name, id, i + 1, levelCount);

      })

      return {
        name: name,
        id: id,
        levels: levels,
        type: config.type || 'production',

        workloadType: 'Выручка',
        workload: 0,
        units: '₽',
        additionalWorkload: 'Время без дела 0%',
        fotCategory: 0,
        fotRevenue: 0,
        performanceStandart: -100,
        lateness: {
          green: 0,
          yellow: 0,
          red: 0
        },
        employees: employees
      };
    }

    function createModalDialog(id, data, onSave) {
      return {
        dialogTemplateName: id + '-modal-template',
        data: data,
        options: {
          modalClass: 'calculation-modal calculation-modal--' + id
        },
        close: result => {
          if (result !== undefined && typeof onSave === 'function') {
            onSave(result);
          }
        }
      }
    }
  });
</script>
