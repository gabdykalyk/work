<script type="text/javascript">
  $(function () {
    const $page = $(document.documentElement);

    const ViewModel = function (positions) {
      this.subscriptions = [];

      this.windowResizeHandler = () => {
        this.viewportSize({ width: $(window).width(), height: $(window).height() });
      };
      this.viewportSize = ko.observable({ width: $(window).width(), height: $(window).height() });

      this.childrenComplete = function () {
        $page.removeClass('hrm-page--initializing');
      };

      this.isBuilt = ko.observable(false);

      function createIntervalsModel(data, needCheck) {

        function createIntervalModel(defaultValue) {
          return ko.observable(defaultValue).extend({
            required: {
              message: 'Обязательное поле'
            },
            hrmDate: {
              params: 'HH:mm',
              message: 'Неверный формат времени'
            }
          })
        }

        const model = ko.validatedObservable(null, { deep: true, live: true });
        const start = createIntervalModel(data.start);
        const end = createIntervalModel(data.end);
        const correct = ko.computed(() => {
          const endMoment = moment(end(), 'HH:mm');
          const startMoment = moment(start(), 'HH:mm');

          if (!needCheck()) return true;

          return endMoment.isAfter(startMoment);
        })
        start.extend({
          validation: {
            validator: () => correct()
          }
        });
        end.extend({
          validation: {
            validator: () => correct()
          }
        });
        model({
          start,
          end,
          correct
        });

        return model;
      }

      this.inputModel = {
        filial: ko.observable('').extend({
          required: {
            message: 'Обязательное поле'
          }
        }),
        date: ko.observable(moment().format('DD.MM.YYYY, dddd')).extend({
          required: {
            message: 'Обязательное поле'
          },
          hrmDate: {
            params: 'DD.MM.YYYY, dddd',
            message: 'Неверный формат даты'
          }
        }),
        shift: ko.observable('').extend({
          required: {
            message: 'Обязательное поле'
          }
        })
      };

      this.inputModel.interval = createIntervalsModel({
        start: '11:00',
        end: '23:00',
      }, () => {
        return !this.changeShift && this.inputModel.shift.peek() != 1
      });

      this.inputModel.shift.subscribe((value) => {
        this.changeShift = 1;
        if (value == 0) {
          this.inputModel.interval().start('11:00');
          this.inputModel.interval().end('23:00');
        } else {
          this.inputModel.interval().start('23:00');
          this.inputModel.interval().end('11:00');
        }
        this.changeShift = 0;
      });


      window.test = this.inputModel.interval;

      this.isInputValid = ko.pureComputed(() => {
        return this.inputModel.date.isValid() && this.inputModel.interval.isValid();
      }, this);


      this.formControlErrorStateMatcher = function (formControl) {
        return ko.pureComputed(() => {
          return !formControl.isValid();
        });
      };


      this.buildCalculation = () => {
        this.isBuilt(true);
      };

      this.createPositionModel = function (data) {
        return {
          ...data
        };
      };

      this.jobsModel = ko.observable({
        positions: positions.map(position => {
          return this.createPositionModel(position)
        })
      });
      this.jobsModel.total = ko.pureComputed(() => {
        return this.jobsModel().positions.reduce((acc, p) => {
          return {
            workload: (acc.workload || 0) + p.workload,
            workloadType: '',
            units: '',
            additionalWorkload: '',
            fotCategory: 100,
            fotRevenue: 100,
            performanceStandart: -100,
            lateness: {
              green: 0,
              yellow: 0,
              red: 0
            },
            employees: (acc.employees || 0) + p.employees.length
          }
        }, {})
      })

      this.isEmployeesCalculated = ko.observable(false);

      this.calculateEmployees = function () {
        this.isEmployeesCalculated(true);
      };

      this.recalculateEmployees = function () {
        this.isEmployeesCalculated(false);

        this.formModel().positions().forEach((position, index) => {
          position.employees(positions[index].employees.map(e => this.createEmployeeModel(e)));
        });

        this.isEmployeesCalculated(true);
      };

      this.addWorkingInterval = function (employee) {
        employee.workingIntervals.push(this.createEmployeeWorkingIntervalModel(''));
      };

      this.addEmployee = function (position) {
        const index = Math.floor(Math.random() * 1000);

        position.employees.push(this.createEmployeeModel({
          name: position.name + ' #' + index,
          workingIntervals: [''],
          rate: position.rate() !== '' ? position.rate() : 600,
          returnRate: 30,
          salaryBulk: 7200,
          bonus: 100,
          fine: 20
        }));
      };

      this.onRateInput = function (position) {
        position.employees().forEach(employee => {
          employee.rate(position.rate());
        });
      };

      this.onEmployeeRateInput = function (position) {
        position.rate('');
      };


      this.getWorkloadTypeName = function (workloadType) {
        switch (workloadType) {
          case 1: return 'Объём товара по всему предприятию';
          case 2: return 'Объём товара по категориям';
        }
      };

      this.getEmployeeWorkingHours = function (employee) {
        return ko.pureComputed(() => {
          if (employee.workingIntervalsValidationObject.isValid()) {
            return employee.workingIntervals().reduce((minutes, interval) => {
              const boundaries = interval.value().split(' – ').map(b => moment(b, 'HH:mm'));

              if (boundaries[0].isAfter(boundaries[1])) {
                boundaries[1].add(1, 'd');
              }

              return minutes + boundaries[1].diff(boundaries[0], 'minutes');
            }, 0);
          } else {
            return 0;
          }
        });
      };

      this.getEmployeeSalaryBulk = function (employee) {
        return ko.pureComputed(() => {
          const minutes = this.getEmployeeWorkingHours(employee)();

          return this.unmaskDecimal(employee.rate()) * (minutes / 60);
        });
      };

      this.getEmployeeSalary = function (employee) {
        return ko.pureComputed(() => {
          const bulk = this.getEmployeeSalaryBulk(employee)();
          const bonus = this.unmaskDecimal(employee.bonus());
          const fine = this.unmaskDecimal(employee.fine());

          return this.unmaskDecimal(bulk + bonus - fine);
        });
      };

      this.getPositionMaxWorkingIntervalCount = function (position) {
        return ko.pureComputed(() => {
          return Math.max(...position.employees().map(e => e.workingIntervals().length));
        });
      };

      this.getCategoriesTooltipText = function (categories) {
        return categories.map(c => c.name).join(', ');
      };

      this.getUnitsSuffixHtml = function (units) {
        switch (units) {
          case '1': return 'шт.';
          case '2': return '<i class="far fa-ruble-sign"></i>';
          case '3': return 'ч.';
        }
      };

      this.formatDecimal = function (value) {
        return Inputmask.format(value, { alias: 'decimal', digits: '2', groupSeparator: ' ', autoGroup: true, allowMinus: false }).replace('.00', '');
      };

      this.unmaskDecimal = function (value) {
        const result = Inputmask.unmask(value, { alias: 'decimal', digits: '2', groupSeparator: ' ', autoGroup: true, allowMinus: false, unmaskAsNumber: true });

        if (result === '') {
          return 0;
        }

        return result;
      };

      this.editableCellControlErrorExtractor = function (control) {
        return ko.pureComputed(() => {
          return !control.isValid() ? { message: control.error() } : null;
        });
      };

      this.formatDuration = function (minutes) {
        let h = Math.floor(minutes / 60).toString();
        h = h.length === 1 ? '0' + h : h;
        let m = (minutes % 60).toString();
        m = m.length === 1 ? '0' + m : m;

        return h + ':' + m;
      };

      this.footerTextHtml = ko.pureComputed(() => {
        if (this.viewportSize().width <= HRM_BREAKPOINTS.mobileMaxWidth) {
          return 'Авторизация позволит <b>настраивать<br> должности</b> и <b>сохранять параметры</b> таблиц для следующих расчетов';
        } else {
          return 'Авторизация позволит <b>настраивать должности</b><br> и <b>сохранять параметры</b> таблиц для следующих расчетов';
        }
      });


      (() => {
        $(window).on('resize', this.windowResizeHandler);
      })();
    };

    const viewModel = new ViewModel([
      {
        name: 'Администратор филиала',
        workloadType: 'Выручка',
        workload: 0,
        units: '₽',
        additionalWorkload: 'Время без дела 0%',
        fotCategory: 0,
        fotRevenue: 0,
        performanceStandart: -100,
        lateness: {
          green: 0,
          yellow: 0,
          red: 0
        },
        employees: [
          {
            name: 'Сергеева Мария Владиславовна',
          }
        ]
      }, {
        name: 'Водители',
        workloadType: 'Выручка',
        workload: 0,
        units: '₽',
        additionalWorkload: '',
        fotCategory: 0,
        fotRevenue: 0,
        performanceStandart: -100,
        lateness: {
          green: 0,
          yellow: 0,
          red: 0
        },
        employees: [
          {},
          {},
          {}
        ]
      },
    ]);

    ViewModel.prototype.dispose = function () {
      $(window).off('resize', this.windowResizeHandler);
      this.subscriptions.forEach(s => s.dispose());
    };

    ko.applyBindings(
      viewModel,
      $page.get()[0]
    );
  });
</script>
